{
  parserClass="com.github.tylersmith34.intellijhashicorpsentinel.SentinelParser"
  parserUtilClass="com.github.tylersmith34.intellijhashicorpsentinel.SentinelParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Sentinel"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.tylersmith34.intellijhashicorpsentinel.psi"
  psiImplPackage="com.github.tylersmith34.intellijhashicorpsentinel.psi.impl"

  elementTypeHolderClass="com.github.tylersmith34.intellijhashicorpsentinel.SentinelTypes"
  elementTypeClass="com.github.tylersmith34.intellijhashicorpsentinel.psi.SentinelElementType"
  tokenTypeClass="com.github.tylersmith34.intellijhashicorpsentinel.psi.SentinelTokenType"

  psiImplUtilClass="com.github.tylersmith34.intellijhashicorpsentinel.psi.impl.SentinelPsiImplUtil"

    tokens = [
        IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        WHITE_SPACE = 'regexp:\s+'
        DOUBLE_QUOTED_STRING="regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"
        SINGLE_QUOTED_STRING="regexp:'([^\\\'\r\n]|\\[^\r\n])*'?"
        COMMENT = "regexp:(//.*)|(#.*)"
        BLOCK_COMMENT = "regexp:/\*([^*]|\*[^/])*\*?(\*/)?"
        NUMBER='regexp:-?(0x)?(0|[1-9])\d*(\.\d+)?([eE][-+]?\d+)?'
        L_BRACKET='['
        R_BRACKET=']'
        L_CURLY='{'
        R_CURLY='}'
        L_PAREN='('
        R_PAREN=')'
        COMMA=','
        EQUALS='='
        ALL='all'
        ANY='any'
        AS='as'
        BREAK='break'
        CASE='case'
        CONTINUE='continue'
        DEFAULT='default'
        ELSE='else'
        FOR='for'
        IF='if'
        WHEN='when'
   ]
}

SimpleFile ::= Definition*
Definition ::= { ImportStatement | ExternalParameters | GlobalVariableDefinition | MainRule | FunctionDeclaration }

//import
ImportStatement ::= import StringLiteral (as IDENTIFIER )?

//External param
ExternalParameters       ::= param IDENTIFIER ( default StringLiteral )?
GlobalVariableDefinition ::= VariableDefinition

//Rules
MainRule       ::= main EQUALS RuleBase
//RuleDefinition ::= IDENTIFIER EQUALS RuleBase
RuleBase       ::= rule [ "when" <expression> ] L_CURLY <expression> R_CURLY

//Functions
FunctionDeclaration ::= IDENTIFIER EQUALS func Function
Function            ::= Parameters FunctionBody
FunctionBody        ::= L_CURLY Statement ReturnStatement  R_CURLY
ReturnStatement     ::= return ( IDENTIFIER | Literal )
Parameters          ::= L_PAREN ( IdentifierList )? R_PAREN
IdentifierList      ::= IDENTIFIER+ ( COMMA IDENTIFIER+ )?
Statement           ::= { VariableDefinition  }*

//Variables
VariableDefinition  ::= IDENTIFIER EQUALS ( Literal | ListDefinition | MapDefinition  )
//TODO use this instead of equals
AssignmentOperators ::= ( AddSubtractOperator | MultipleDivideOperator ) EQUALS


ListDefinition     ::= L_BRACKET ( ElementList )? R_BRACKET
ElementList ::= Element+ ( COMMA Element)*
Element     ::= Literal | ListDefinition | MapDefinition

MapDefinition    ::= L_CURLY ( KeyedElementList )? R_CURLY
KeyedElementList ::= KeyedElement ( COMMA KeyedElement COMMA?)*
KeyedElement     ::= Element ":" Element

//primitive types
Literal ::= Number | NumberLiteral | Decimal | octal_lit | hex_lit | Float | StringLiteral | BooleanLiteral | NullLiteral | UndefinedLiteral
BooleanLiteral::= true | false
NullLiteral::= null
UndefinedLiteral::= undefined

octal_digit   ::= 1|2|3|4|5|6|7
hex_digit     ::= 1|2|3|4|5|6|7 | "A" | "F" | "a" | "f"
letter        ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
escaped_char  ::= '\' ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | '\' | '"' )


<expression> ::= unary_expr? | {<expression>} binary_op {<expression>}
unary_expr  ::= <primary_expr> | unary_op {unary_expr}
<primary_expr> ::=
    Operand |
    {<primary_expr>} Selector |
    {<primary_expr>} Index |
    {<primary_expr>} Slice |
    {<primary_expr>} Arguments
binary_op  ::= logical_op | set_op | rel_op | AddSubtractOperator | MultipleDivideOperator | else_op
logical_op ::= "and" | "or" | "xor"
set_op     ::= ["not"] ( "contains" | "in" )
rel_op     ::= "==" | "!=" | "<" | "<=" | ">" | ">=" | "is" | "is not" | "matches" | "not matches"
AddSubtractOperator     ::= "+" | "-"
MultipleDivideOperator  ::= "*" | "/" | "%"
else_op    ::= "else"
unary_op   ::= "+" | "-" | "!" | "not"
Operand    ::= Literal | IDENTIFIER | "(" <expression> ")"
Selector  ::= "." IDENTIFIER
Index     ::= "[" <expression> "]"
Slice     ::= "[" ( <expression> ) ":" ( <expression> ) "]" | "[" ( <expression> ) ":" <expression> ":" <expression> "]"
Arguments ::= "(" [ ( <expression> | Literal [ "," <expression> ] ) [ "..." ] [ "," ] ] ")"

NumberLiteral ::= Decimal | octal_lit | hex_lit
Decimal      ::= '-'? DecimalDigit+ ('.' DecimalDigit+)?
DecimalDigit ::= 1|2|3|4|5|6|7|8|9|0
octal_lit    ::= "0" ( octal_digit )
hex_lit      ::= "0" ( "x" | "X" ) hex_digit { hex_digit }
Float ::= decimals "." ( decimals )* ( exponent )? | decimals exponent | "." decimals ( exponent )?
decimals  ::= Decimal*
exponent  ::= ( "e" | "E" ) [ "+" | "-" ] decimals

StringLiteral       ::= ('"' ( letter | escaped_char)* '"') | DOUBLE_QUOTED_STRING | SINGLE_QUOTED_STRING
unicode_value    ::= little_u_value | big_u_value | escaped_char
byte_value       ::= octal_byte_value | hex_byte_value
octal_byte_value ::= '\' octal_digit octal_digit octal_digit
hex_byte_value   ::= '\' "x" hex_digit hex_digit
little_u_value   ::= '\' "u" hex_digit hex_digit hex_digit hex_digit
big_u_value      ::= '\' "U" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit


QuantExpr ::= QuantOp <expression> "as" [ IDENTIFIER "," ] IDENTIFIER "{" <expression> R_CURLY
QuantOp   ::= "all" | "any" | "filter"
ExpressionStmt ::= <expression>
Assignment ::= AssignExpr AssignmentOperators <expression>
AssignExpr ::= IDENTIFIER
IfStmt ::= "if" <expression> Block [ "else" ( IfStmt | Block ) ]
CaseStmt ::= "case" [ <expression> ] "{" ( CaseWhenClause ) R_CURLY
CaseWhenClause ::= CaseWhenCase ":" StatementList
CaseWhenCase ::= "when" <expression> ( "," <expression> ) | "else"
ForStmt ::= "for" Expressions "as" ( IDENTIFIER "," ) IDENTIFIER Block
BreakStmt ::= "break"
ContinueStmt ::= "continue"






private EOL ::= CRLF
private not_EOL ::= !CRLF
private not_EOL ::= !(func)
private not_terminator_or_next_value ::= !(R_CURLY|')'|']'|value)
private not_brace_or_next_value ::= !(R_CURLY|value)
private not_paren_or_next_value ::= !(')'|value)
private not_bracket_or_next_value ::= !(']'|(Literal | array | object))
