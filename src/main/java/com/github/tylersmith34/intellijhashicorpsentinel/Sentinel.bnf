{
  parserClass="com.github.tylersmith34.intellijhashicorpsentinel.SentinelParser"
  parserUtilClass="com.github.tylersmith34.intellijhashicorpsentinel.SentinelParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Sentinel"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.tylersmith34.intellijhashicorpsentinel.psi"
  psiImplPackage="com.github.tylersmith34.intellijhashicorpsentinel.psi.impl"

  elementTypeHolderClass="com.github.tylersmith34.intellijhashicorpsentinel.SentinelTypes"
  elementTypeClass="com.github.tylersmith34.intellijhashicorpsentinel.psi.SentinelElementType"
  tokenTypeClass="com.github.tylersmith34.intellijhashicorpsentinel.psi.SentinelTokenType"

  psiImplUtilClass="com.github.tylersmith34.intellijhashicorpsentinel.psi.impl.SentinelPsiImplUtil"

    tokens = [
        IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        WHITE_SPACE = 'regexp:\s+'
        DOUBLE_QUOTED_STRING="regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"
        SINGLE_QUOTED_STRING="regexp:'([^\\\'\r\n]|\\[^\r\n])*'?"
        COMMENT = "regexp:(//.*)|(#.*)"
        BLOCK_COMMENT = "regexp:/\*([^*]|\*[^/])*\*?(\*/)?"
        NUMBER='regexp:-?(0x)?(0|[1-9])\d*(\.\d+)?([eE][-+]?\d+)?'
        L_BRACKET='['
        R_BRACKET=']'
        L_CURLY='{'
        R_CURLY='}'
        L_PAREN='('
        R_PAREN=')'
        COMMA=','
        PERIOD='.'
        EQUALS='='
   ]
}

//SimpleFile ::= IfStatement*
SimpleFile ::= Definition*
Definition ::= { ImportStatement | ExternalParameters | GlobalVariableDefinition | MainRule | RuleDefinition | FunctionDeclaration }

//import
ImportStatement ::= import StringLiteral (as IDENTIFIER )?

//External param
//TODO use `Literal` instead
ExternalParameters       ::= param IDENTIFIER ( default StringLiteral )?
GlobalVariableDefinition ::= VariableDefinition

//Rules
MainRule       ::= main EQUALS RuleBase
MainRuleBlock  ::= L_CURLY BooleanExpressions R_CURLY
RuleDefinition ::= IDENTIFIER EQUALS RuleBase
RuleBase       ::= rule ( when BooleanExpressions )? MainRuleBlock

//Functions
FunctionDeclaration ::= IDENTIFIER EQUALS func Function
Function            ::= Parameters FunctionBody
FunctionBody        ::= L_CURLY FunctionStatement* ReturnStatement  R_CURLY
ReturnStatement     ::= return ( IDENTIFIER | Literal )
Parameters          ::= L_PAREN ( IdentifierList )? R_PAREN
IdentifierList      ::= IDENTIFIER+ ( COMMA IDENTIFIER+ )*
FunctionCall        ::= IDENTIFIER Parameters

//Statements
FunctionStatement   ::= VariableDefinition | IfStatement | ForStatement | FunctionCall
Statement           ::= VariableDefinition | IfStatement | ReturnStatement | ForStatement | FunctionCall


// If Statements
IfStatement        ::= if ( BooleanExpressions | L_PAREN BooleanExpressions R_PAREN ) Block ( else ( IfStatement | Block ) )?
Block              ::= L_CURLY Statement R_CURLY

//Boolean expressions
BooleanExpressions ::= BooleanExpression+ (LogicalOperator BooleanExpression)*
BooleanExpression  ::= FunctionCall |
    UnaryOperator ( IDENTIFIER | Literal )? |
    ( IDENTIFIER | Literal ) ( SetOperator | ComparisonOperator | UnaryOperator | MultipleDivideOperator | AddSubtractOperator | LogicalOperator ) ( IDENTIFIER | Literal ) |
    ElseOperator
ElseOperator    ::= else Literal
LogicalOperator ::= and | or | xor
SetOperator     ::= (not)? ( contains | in )
ComparisonOperator     ::= "==" | "!=" | '<' | "<=" | ">" | ">=" | "is" | "is not" | "matches" | "not matches"
AddSubtractOperator     ::= "+" | "-"
MultipleDivideOperator  ::= "*" | "/" | "%"
UnaryOperator   ::= "+" | "-" | "!" | not


// For Statements
ForBlock     ::= L_CURLY ( Statement | BreakStmt | ContinueStmt ) R_CURLY
ForStatement ::= for IDENTIFIER as ( IDENTIFIER "," )? IDENTIFIER ForBlock
BreakStmt    ::= break
ContinueStmt ::= continue


//Variables
VariableDefinition ::= IDENTIFIER ( AddSubtractOperator | MultipleDivideOperator )? EQUALS ( Literal | ListDefinition | MapDefinition | FunctionCall | QuantifierExpression )
ListDefinition     ::= L_BRACKET ( ElementList )? R_BRACKET
ElementList        ::= Element+ ( COMMA Element)*
Element            ::= Literal | ListDefinition | MapDefinition
MapDefinition      ::= L_CURLY ( KeyedElementList )? R_CURLY
KeyedElementList   ::= KeyedElement ( COMMA KeyedElement COMMA?)*
KeyedElement       ::= Element ":" Element

QuantifierExpression ::= QuantifierOperator DotIdentifier as IDENTIFIER L_CURLY BooleanExpressions  R_CURLY
QuantifierOperator   ::= all | any | filter
DotIdentifier ::= IDENTIFIER+ (Selector | (L_BRACKET StringLiteral R_BRACKET ) )*
Selector  ::= "." IDENTIFIER


//primitive types
Literal ::= Number | NumberLiteral | Decimal | OctalLiteral | HexLiteral | Float | StringLiteral | BooleanLiteral | NullLiteral | UndefinedLiteral
BooleanLiteral::= true | false
NullLiteral::= null
UndefinedLiteral::= undefined
NumberLiteral ::= Decimal | OctalLiteral | HexLiteral
OctalLiteral    ::= "0" ( OctalDigit )
OctalDigit   ::= 1|2|3|4|5|6|7
HexDigit     ::= 1|2|3|4|5|6|7 | "A" | "F" | "a" | "f"
Letter        ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
EscapedCharacter  ::= '\' ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | '\' | '"' )
HexLiteral      ::= "0" ( "x" | "X" ) HexDigit { HexDigit }
Decimal      ::= '-'? DecimalDigit+ ('.' DecimalDigit+)?
DecimalDigit ::= 1|2|3|4|5|6|7|8|9|0
Float ::= decimals "." ( decimals )* ( exponent )? | decimals exponent | "." decimals ( exponent )?
decimals  ::= Decimal*
exponent  ::= ( "e" | "E" ) [ "+" | "-" ] decimals
StringLiteral       ::= ('"' ( Letter | EscapedCharacter)* '"') | DOUBLE_QUOTED_STRING | SINGLE_QUOTED_STRING

//<condition> ::= <unary_expression> | (<condition>)* BinaryOperation (<condition>)*
//<unary_expression>  ::= <primary_expression> | UnaryOperator <unary_expression>
//<primary_expression> ::=
//    Operand |
//    (<primary_expression>)* Selector |
//    (<primary_expression>)* Index |
//    (<primary_expression>)* Slice |
//    (<primary_expression>)* Arguments
//BinaryOperation  ::= LogicalOperator | SetOperator | ComparisonOperator | AddSubtractOperator | MultipleDivideOperator | ElseOperator


//Operand    ::= Literal | IDENTIFIER | "(" <condition> ")"
//Index     ::= "[" <condition> "]"
//Slice     ::= "[" ( <condition> ) ":" ( <condition> ) "]" | "[" ( <condition> ) ":" <condition> ":" <condition> "]"
//Arguments ::= "(" [ ( <condition> | Literal [ "," <condition> ] ) [ "..." ] [ "," ] ] ")"


//unicode_value    ::= little_u_value | big_u_value | EscapedCharacter
//byte_value       ::= octal_byte_value | hex_byte_value
//octal_byte_value ::= '\' OctalDigit OctalDigit OctalDigit
//hex_byte_value   ::= '\' "x" HexDigit HexDigit
//little_u_value   ::= '\' "u" HexDigit HexDigit HexDigit HexDigit
//big_u_value      ::= '\' "U" HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
//
//
//
//Assignment ::= AssignExpr AssignmentOperators <condition>
//AssignExpr ::= IDENTIFIER
//
//
//CaseStmt ::= "case" [ <condition> ] "{" ( CaseWhenClause ) R_CURLY
//CaseWhenClause ::= CaseWhenCase ":" StatementList
//CaseWhenCase ::= "when" <condition> ( "," <condition> ) | "else"

