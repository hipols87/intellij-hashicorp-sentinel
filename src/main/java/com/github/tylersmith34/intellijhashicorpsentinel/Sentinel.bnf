{
  parserClass="com.github.tylersmith34.intellijhashicorpsentinel.SentinelParser"
  parserUtilClass="com.github.tylersmith34.intellijhashicorpsentinel.SentinelParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Sentinel"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.tylersmith34.intellijhashicorpsentinel.psi"
  psiImplPackage="com.github.tylersmith34.intellijhashicorpsentinel.psi.impl"

  elementTypeHolderClass="com.github.tylersmith34.intellijhashicorpsentinel.SentinelTypes"
  elementTypeClass="com.github.tylersmith34.intellijhashicorpsentinel.psi.SentinelElementType"
  tokenTypeClass="com.github.tylersmith34.intellijhashicorpsentinel.psi.SentinelTokenType"

  psiImplUtilClass="com.github.tylersmith34.intellijhashicorpsentinel.psi.impl.SentinelPsiImplUtil"

    tokens = [
        IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        WHITE_SPACE = 'regexp:\s+'
        DOUBLE_QUOTED_STRING="regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"
        SINGLE_QUOTED_STRING="regexp:'([^\\\'\r\n]|\\[^\r\n])*'?"
        COMMENT = "regexp:(//.*)|(#.*)"
        BLOCK_COMMENT = "regexp:/\*([^*]|\*[^/])*\*?(\*/)?"
        NUMBER='regexp:-?(0x)?(0|[1-9])\d*(\.\d+)?([eE][-+]?\d+)?'
        L_BRACKET='['
        R_BRACKET=']'
        L_CURLY='{'
        R_CURLY='}'
        L_PAREN='('
        R_PAREN=')'
        COMMA=','
        PERIOD='.'
        EQUALS='='
   ]
}

//SimpleFile ::= IfStatement*
SimpleFile ::= Definition*
Definition ::= { ImportStatement | ExternalParameters | GlobalVariableDefinition | MainRule | FunctionDeclaration }

//import
ImportStatement ::= import StringLiteral (as IDENTIFIER )?

//External param
//TODO use `Literal` instead
ExternalParameters       ::= param IDENTIFIER ( default StringLiteral )?
GlobalVariableDefinition ::= VariableDefinition

//Rules
MainRule       ::= main EQUALS RuleBase
//RuleDefinition ::= IDENTIFIER EQUALS RuleBase
RuleBase       ::= rule ( "when" <condition> )? L_CURLY <condition> R_CURLY

//Functions
FunctionDeclaration ::= IDENTIFIER EQUALS func Function
Function            ::= Parameters FunctionBody
FunctionBody        ::= L_CURLY FunctionStatement* ReturnStatement  R_CURLY
ReturnStatement     ::= return ( IDENTIFIER | Literal )
Parameters          ::= L_PAREN ( IdentifierList )? R_PAREN
IdentifierList      ::= IDENTIFIER+ ( COMMA IDENTIFIER+ )?
FunctionStatement           ::= VariableDefinition | IfStatement
Statement           ::= VariableDefinition | IfStatement | ReturnStatement

FunctionCall        ::= IDENTIFIER Parameters

//Variables
VariableDefinition  ::= IDENTIFIER EQUALS ( Literal | ListDefinition | MapDefinition  )
//TODO use this instead of equals
AssignmentOperators ::= ( AddSubtractOperator | MultipleDivideOperator )? EQUALS


ListDefinition     ::= L_BRACKET ( ElementList )? R_BRACKET
ElementList ::= Element+ ( COMMA Element)*
Element     ::= Literal | ListDefinition | MapDefinition

MapDefinition    ::= L_CURLY ( KeyedElementList )? R_CURLY
KeyedElementList ::= KeyedElement ( COMMA KeyedElement COMMA?)*
KeyedElement     ::= Element ":" Element

QuantifierExpression ::= QuantifierOperator DotIdentifier as IDENTIFIER L_CURLY  R_CURLY
QuantifierOperator   ::= all | any | filter

DotIdentifier ::= IDENTIFIER+ (Selector | (L_BRACKET StringLiteral R_BRACKET ) )*

//primitive types
Literal ::= Number | NumberLiteral | Decimal | octal_lit | hex_lit | Float | StringLiteral | BooleanLiteral | NullLiteral | UndefinedLiteral
BooleanLiteral::= true | false
NullLiteral::= null
UndefinedLiteral::= undefined

octal_digit   ::= 1|2|3|4|5|6|7
hex_digit     ::= 1|2|3|4|5|6|7 | "A" | "F" | "a" | "f"
letter        ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
escaped_char  ::= '\' ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | '\' | '"' )

Block ::= L_CURLY Statement R_CURLY
IfStatement ::= if ( boolean_expression | L_PAREN boolean_expression R_PAREN ) Block ( else ( IfStatement | Block ) )?

boolean_expression ::= FunctionCall |
 UnaryOperator ( IDENTIFIER | Literal ) |
  ( IDENTIFIER | Literal ) ( SetOperator | ComparisonOperator | UnaryOperator) ( IDENTIFIER | Literal )

<condition> ::= <unary_expression> | (<condition>)* BinaryOperation (<condition>)*
<unary_expression>  ::= <primary_expression> | UnaryOperator <unary_expression>
<primary_expression> ::=
    Operand |
    (<primary_expression>)* Selector |
    (<primary_expression>)* Index |
    (<primary_expression>)* Slice |
    (<primary_expression>)* Arguments
BinaryOperation  ::= LogicalOperator | SetOperator | ComparisonOperator | AddSubtractOperator | MultipleDivideOperator | ElseOperator
LogicalOperator ::= and | or | xor
SetOperator     ::= (not)? ( contains | in )
ComparisonOperator     ::= "==" | "!=" | "<" | "<=" | ">" | ">=" | "is" | "is not" | "matches" | "not matches"
AddSubtractOperator     ::= "+" | "-"
MultipleDivideOperator  ::= "*" | "/" | "%"
ElseOperator    ::= else Literal
UnaryOperator   ::= "+" | "-" | "!" | not

Operand    ::= Literal | IDENTIFIER | "(" <condition> ")"
Selector  ::= "." IDENTIFIER
Index     ::= "[" <condition> "]"
Slice     ::= "[" ( <condition> ) ":" ( <condition> ) "]" | "[" ( <condition> ) ":" <condition> ":" <condition> "]"
Arguments ::= "(" [ ( <condition> | Literal [ "," <condition> ] ) [ "..." ] [ "," ] ] ")"

NumberLiteral ::= Decimal | octal_lit | hex_lit
Decimal      ::= '-'? DecimalDigit+ ('.' DecimalDigit+)?
DecimalDigit ::= 1|2|3|4|5|6|7|8|9|0
octal_lit    ::= "0" ( octal_digit )
hex_lit      ::= "0" ( "x" | "X" ) hex_digit { hex_digit }
Float ::= decimals "." ( decimals )* ( exponent )? | decimals exponent | "." decimals ( exponent )?
decimals  ::= Decimal*
exponent  ::= ( "e" | "E" ) [ "+" | "-" ] decimals

StringLiteral       ::= ('"' ( letter | escaped_char)* '"') | DOUBLE_QUOTED_STRING | SINGLE_QUOTED_STRING
unicode_value    ::= little_u_value | big_u_value | escaped_char
byte_value       ::= octal_byte_value | hex_byte_value
octal_byte_value ::= '\' octal_digit octal_digit octal_digit
hex_byte_value   ::= '\' "x" hex_digit hex_digit
little_u_value   ::= '\' "u" hex_digit hex_digit hex_digit hex_digit
big_u_value      ::= '\' "U" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit



Assignment ::= AssignExpr AssignmentOperators <condition>
AssignExpr ::= IDENTIFIER


CaseStmt ::= "case" [ <condition> ] "{" ( CaseWhenClause ) R_CURLY
CaseWhenClause ::= CaseWhenCase ":" StatementList
CaseWhenCase ::= "when" <condition> ( "," <condition> ) | "else"
ForStmt ::= "for" Expressions "as" ( IDENTIFIER "," ) IDENTIFIER Block
BreakStmt ::= "break"
ContinueStmt ::= "continue"






private EOL ::= CRLF
private not_EOL ::= !CRLF
private not_EOL ::= !(func)
private not_terminator_or_next_value ::= !(R_CURLY|')'|']'|value)
private not_brace_or_next_value ::= !(R_CURLY|value)
private not_paren_or_next_value ::= !(')'|value)
private not_bracket_or_next_value ::= !(']'|(Literal | array | object))
